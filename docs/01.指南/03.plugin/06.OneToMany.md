---
title: OneToMany
date: 2023-06-02 17:26:08
permalink: /pages/2889b0/
---

## 一对多数据查询

> 场景: 一对多数据查询(自动编排分组)，正所谓一对多查询也就是查询的结果会有映射关系是一对多的下面来挨个看看
> 比如: 我现在要查询年龄为18岁的所有用户，那么我查询出来的结果就是一个Map<Integer, List<UserInfo>>，key为年龄，value为年龄为18岁的所有用户

### of
> 场景: 在进行数据查询之前需要构造的查询条件使用OneToMany.of()进行构造，后续分组会通过of里的参数自动进行分组
> 注: 排除复杂条件查询之外的条件都会通过SFunction返回值进行匹配

```java
final OneToMany<UserInfo, Integer, UserInfo> of = OneToMany.of(UserInfo::getAge);
// 代表后续的查询条件除去复杂条件查询之外 都会通过age进行匹配 并且返回的实体的age会作为Map中的Key，value默认为对应的实体，如果有调用value的话则为value方法中的返回值
```

### value

> 场景 我们在封装Map的key的时候List中的泛型如果不想要整个实体的话可以使用value方法指定返回的字段

```java

Map<Integer, List<String>> userAgeNameMap =
              OneToMany.of(UserInfo::getAge).value(UserInfo::getName).query();
// 将UserInfo实体对应表中的的数据全都查询出来放到一个Map中,通过年龄分组，Map的key为age，value为用户的name
```

### in

> 场景 拼接条件：in,也就是查询某个字段在某个集合中的数据（批量查询）


```java
List<Integer> userAges = Arrays.asList(21, 24);
Map<Integer, List<String>> userAgeNameMap =
                OneToMany.of(UserInfo::getAge)
                .in(userAges)
                .value(UserInfo::getName)
                .query();

// 将UserInfo实体对应表中的age属性所对应的字段等于21或者24的数据全都查询出来放到一个Map中,通过年龄分组，Map的key为age，value为用户的name
```

### condition

> 场景：复杂查询自定义拼接

```java

Map<String, List<UserInfo>> nameUsersMap =
              OneToMany.of(UserInfo::getName)
                  .in(userNames)
                  .condition(w -> w.le(UserInfo::getAge, 21))
                  .query();

// 将UserInfo实体对应表中的name属性所对应的字段等于userNames集合中的数据并且age小于等于21的数据全都查询出来放到一个Map中,通过name分组，Map的key为name，value为用户的UserInfo实体
```

## 测试用例地址
> [OneToManyTest](https://gitee.com/dromara/stream-query/blob/main/stream-plugin/stream-plugin-mybatis-plus/src/test/java/org/dromara/streamquery/stream/plugin/mybatisplus/OneToManyTest.java)
