---
title: Maps
date: 2023-05-10 17:10:05
permalink: /pages/8cc794/
name: 臧臧
href: https://gitee.com/EliaukU
---


## oneToManyToOne
> 这个方法实现了一个将一对多关系映射到一对一关系的功能。具体而言，它接受两个映射（middleMap 和 attachMap）以及一个可选的一元操作（unaryOperator），并构建一个新的映射，其中每个键对应一个值列表。

### 参数

```java
middleMap (Map<K, C>): 一个映射，其键类型为 K，值类型为一个集合 C，该集合中的元素类型为 A。这个映射表示一个从 K 类型到 A 类型的一对多关系。
attachMap (Map<A, V>): 一个映射，其键类型为 A，值类型为 V。这个映射表示一个从 A 类型到 V 类型的一对一关系。
unaryOperator (UnaryOperator<Steam<V>>... unaryOperator): 可选的一元操作，接受一个 Steam<V> 类型的参数并返回一个新的 Steam<V>。这个操作在将 A 类型的值转换为 V 类型的值时可能会应用。
```
### 返回值

```java
Steam<Map.Entry<K, List<V>>>
```
>返回一个新的流，其中包含了映射条目。每个条目的键类型为 K，值类型为一个 V 类型的列表。这个列表包含了从 middleMap 和 attachMap 组合得到的一对一关系。
### 示例

```java
Map<String, List<Integer>> middleMap = new HashMap<>();
middleMap.put("a", Arrays.asList(1, 2));
middleMap.put("b", Arrays.asList(3));

Map<Integer, String> attachMap = new HashMap<>();
attachMap.put(1, "one");
attachMap.put(2, "two");
attachMap.put(3, "three");
```
>我们可以使用 oneToManyToOne 方法将这两个映射组合成一个新的映射，如下所示：
```java
Steam<Map.Entry<String, List<String>>> result = oneToManyToOne(middleMap, attachMap);
```
>结果流将包含以下映射条目：
>键："a"，值：["one", "two"]
>键："b"，值：["three"]

## oneToOneToOne

>本方法返回一个 Steam 对象，其中包含一个与另一个映射具有一对一关系的映射的条目，中间值存储在第三个映射中。第二个映射的值可以使用提供的 UnaryOperator 进行转换。

### 参数
>middleMap - 中间映射，键类型为 K，值类型为 A 的 Map 对象。
attachMap - 最终映射，键类型为 A，值类型为 V 的 Map 对象。
unaryOperator - 可选的 UnaryOperator 数组，用于转换最终映射中的值。

### 类型参数
>K - 中间映射中的键的类型。
A - 中间映射中的值和最终映射中的键的类型。
V - 最终映射中的值的类型。

### 返回值
>一个 Stream 对象，其中包含最终映射的条目，键类型为 K，值类型为 V。

### 示例
```java
Map<Integer, String> middleMap = new HashMap<>();
middleMap.put(1, "one");
middleMap.put(2, "two");
middleMap.put(3, "three");
Map<String, String> attachMap = new HashMap<>();
attachMap.put("one", "first");
attachMap.put("two", "second");
attachMap.put("three", "third");

UnaryOperator<String> operator = s -> String::toUpperCase;
Steam<Map.Entry<Integer, String>> steam = Maps.oneToOneToOne(middleMap, attachMap, operator);

steam.forEach(System.out::println);

输出：
  1=FIRST 
  2=SECOND 
  3=THIRD
```

## oneToOneToMany

> 将一个中间映射（middleMap）和一个附加映射（attachMap）转换为一对多的关系。可以使用提供的一元操作符（unaryOperator）对附加映射中的值进行进一步处理。

### 参数

>middleMap：一个 java.util.Map 对象，表示中间映射。
attachMap：一个 java.util.Map 对象，表示附加映射。
unaryOperator：一个 java.util.function.UnaryOperator 对象数组，用于对附加映射中的值进行操作。

### 类型参数
>K：表示键的类型。
A：表示中间映射值的类型。
V：表示附加映射值的类型

### 返回值
>返回一个 Steam 对象，该对象包含了由键-值对组成的列表，其中每个键对应一个值列表。

### 示例
```java
// 创建中间映射
    Map<Integer, String> middleMap = new HashMap<>();
        middleMap.put(1, "A");
        middleMap.put(2, "B");

        // 创建附加映射
        Map<String, List<String>> attachMap = new HashMap<>();
        attachMap.put("A", Lists.of("Apple", "Apricot"));
        attachMap.put("B", Lists.of("Banana", "Blueberry"));

// 调用oneToOneToMany方法
final Steam<Map.Entry<Integer, List<String>>> result = Maps.oneToOneToMany(middleMap, attachMap);

        // 遍历结果并打印
        result.forEach(entry -> {
        System.out.println("Key: " + entry.getKey());
        System.out.println("Values: " + entry.getValue());
        System.out.println("-----");
        });
    输出：
        Key: 1
        Values: [Apple, Apricot]
        -----
        Key: 2
        Values: [Banana, Blueberry]
        -----
```

## merge

>合并两个映射（m1 和 m2）的键值对，并根据提供的合并函数（mergeFunction）对具有相同键的值进行合并。

### 参数

>m1：一个 java.util.Map 对象，表示第一个映射。
m2：一个 java.util.Map 对象，表示第二个映射。
mergeFunction：一个 SerThiFunc 对象，表示用于合并值的合并函数。

### 类型参数
>K：表示键的类型。
V：表示值的类型。

### 返回值

>返回一个合并后的映射，其中包含了 m1 和 m2 的键值对。

### 示例
```java
Map<String, Integer> m1 = new HashMap<>();
    m1.put("A", 1);
    m1.put("B", 2);

    // 创建第二个映射
    Map<String, Integer> m2 = new HashMap<>();
    m2.put("B", 3);
    m2.put("C", 4);

    // 定义合并函数
    SerThiFunc<String, Integer, Integer, Integer> mergeFunction = (key, v1, v2) -> v1 + v2;

    // 调用merge方法
    Map<String, Integer> result = Maps.merge(m1, m2, mergeFunction);

    // 打印合并结果
    System.out.println("合并后的映射：" + result);
    输出：
        合并后的映射：{A=1, B=5, C=4}
```

## filter
> 根据提供的断言（biPredicate），过滤给定映射（map）的键值对，并返回满足条件的键值对所组成的新映射。

### 参数
>map：一个 java.util.Map 对象，表示待过滤的映射。
biPredicate：一个 BiPredicate 对象，表示条件谓词，用于过滤键值对。

### 类型参数
>K：表示键的类型。
V：表示值的类型。

### 返回值
>返回一个新的映射，其中包含满足条件的键值对。

### 示例
```java
// 创建映射
    Map<String, Integer> map = new HashMap<>();
    map.put("A", 1);
    map.put("B", 2);
    map.put("C", 3);
    
    BiPredicate<String, Integer> biPredicate = (key, value) -> value % 2 == 0;
    
    Map<String, Integer> filteredMap = Maps.filter(map, biPredicate);
    
    System.out.println("过滤后的映射：" + filteredMap);
    输出：
        过滤后的映射：{B=2}
```

## flatten

> 将嵌套的映射（nestedMap）展开为扁平化的映射，并使用指定的分隔符（delimiter）连接键。

### 参数
>nestedMap：一个 java.util.Map 对象，表示嵌套的映射。
delimiter：一个 String 对象，表示用于连接键的分隔符。

### 类型参数
>K：表示键的类型。 
>V：表示值的类型。

### 返回值
>返回一个扁平化的映射，其中键由原始映射的键及内部映射的键以分隔符连接而成

### 示例
```java
Map<String, Map<String, Integer>> nestedMap = new HashMap<>();
    Map<String, Integer> innerMap1 = new HashMap<>();
    innerMap1.put("A", 1);
    innerMap1.put("B", 2);
    nestedMap.put("Key1", innerMap1);
    Map<String, Integer> innerMap2 = new HashMap<>();
    innerMap2.put("C", 3);
    innerMap2.put("D", 4);
    nestedMap.put("Key2", innerMap2);

    // 定义分隔符
    String delimiter = "-";

    // 调用flatten方法
    Map<String, Integer> flattenedMap = Maps.flatten(nestedMap, delimiter);

    // 打印扁平化结果
    System.out.println("扁平化的映射：" + flattenedMap);
    输出：
        扁平化的映射：{Key1-A=1, Key1-B=2, Key2-C=3, Key2-D=4}
```

## computeIfAbsent

> 根据给定的键（key），如果映射（map）中不存在该键，则使用提供的映射函数（mappingFunction）计算并添加相应的值。
### 参数
>map：一个 java.util.Map 对象，表示映射。
key：一个 K 类型的对象，表示键。
mappingFunction：一个 Function 对象，表示映射函数。

### 类型参数
>K：表示键的类型。
V：表示值的类型。

### 返回值
>如果映射中已经存在给定的键，则返回对应的值；如果映射中不存在给定的键，则使用映射函数计算并添加相应的值，然后返回该值。

### 示例
```java
// 创建映射
    Map<String, Integer> map = new HashMap<>();
    map.put("A", 1);
    map.put("B", 2);

    // 定义映射函数
    Function<String, Integer> mappingFunction = key -> key.length();

    // 调用computeIfAbsent方法
    Integer value1 = Maps.computeIfAbsent(map, "A", mappingFunction);
    Integer value2 = Maps.computeIfAbsent(map, "C", mappingFunction);

    // 打印结果
    System.out.println("键 'A' 的值：" + value1);
    System.out.println("键 'C' 的值：" + value2);
    System.out.println("更新后的映射：" + map);
    输出:
        键 'A' 的值：1
        键 'C' 的值：3
        更新后的映射：{A=1, B=2, C=3}
```

## 测试用例地址
> [OneToManyTest](https://gitee.com/dromara/stream-query/blob/main/stream-plugin/stream-plugin-mybatis-plus/src/test/java/org/dromara/streamquery/stream/plugin/mybatisplus/OneToManyTest.java)
